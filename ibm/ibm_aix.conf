filter {
    # IBM AIX filter version 1.0.0
    if [type] and ([type] == "syslog" and ![dataType]) {
        if ([message] and (("TTY" in [message] and "PWD" in [message] and "USER" in [message] and "COMMAND" in [message]) or ("command continued" in [message]) 
        or ([message] =~/(\w+): ([A-Za-z0-9_-](\s)?)+\[[0-9]+\]:/) or ([message] =~/(\w+): (\w+): [0-9-]+(\s)?\[[0-9]+\] /) or ([message]=~/(\w)+: last message repeated [0-9]+ time(s)?/)
        or ([message]=~/(\w+): from (\w+) to (\w+) at /))){
            #......................................................................#
            #Generating dataSource field required by CurrelationRulesEngine
            #Checks if exists, if not evaluate to the host variable
            if (![dataSource]){
                mutate {
                add_field => { "dataSource" => "%{host}" }
                }
            }
            #......................................................................# 
            #Generating dataType field required by CurrelationRulesEngine
            mutate {
                add_field => { "dataType" => "ibm-aix" }
            }
            #......................................................................#
            #Using grok to parse header of the message
            grok {
                match => {
                    "message" => "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?%{SYSLOGTIMESTAMP:timestamp}(\s)?(Message forwarded from )?%{DATA:hostname}(\s)?:(\s)?%{GREEDYDATA:msg_init}"
                }
            }
            #......................................................................#
            #Checking that the msg_init field exists
            if ([msg_init]){
                #......................................................................#
                #Format where the TTY,PWD,USER,COMMAND fields or the Command Continued field exist
                if (("TTY" in [message] and "PWD" in [message] and "USER" in [message] and "COMMAND" in [message]) or ("command continued" in [message]) or ([message] =~/(\w)+: last message repeated [0-9]+ time(s)?/)
                or ([message] =~/(\w+): from (\w+) to (\w+) at /)){
                    #......................................................................#
                    #Using grok to parse msg_init
                    grok {
                        match => {
                            "msg_init" => [
                                "%{DATA:commandType}(\s)?:(\s)?%{DATA:username}(\s)?:(\s)?TTY(\s)?=(\s)?%{DATA:tty}(\s)?;(\s)?PWD(\s)?=(\s)?%{DATA:pwd}(\s)?;(\s)?USER(\s)?=(\s)?%{DATA:user}(\s)?;(\s)?COMMAND(\s)?=(\s)?%{GREEDYDATA:command}",
                                "%{DATA:commandType}(\s)?:(\s)?%{DATA:username}(\s)?:(\s)?\(command continued\)(\s)?%{GREEDYDATA:command}",
                                "%{DATA:commandType}: from %{DATA:src_user} to %{DATA:dest_user} at %{GREEDYDATA:command_path}",
                                "%{GREEDYDATA:msg}"
                                ]
                        }
                    }
                }
                #......................................................................#
                #Format (\w+): ([A-Za-z0-9_-](\s)?)+:?(\s)?([0-9-]+)?(\s)?\[[0-9]{5,9}+\]
                if ([message] =~/(\w+): ([A-Za-z0-9_-](\s)?)+:?(\s)?([0-9-]+)?(\s)?\[[0-9]{5,9}\]/){
                    #......................................................................#
                    #Format where the LENGTH, SESSIONID, ENTRYID, STATEMENT, USERID, USERHOST, ACTION, RETURNCODE, OBJ$CREATOR, OBJ$NAME, and OS$USERID fields exist
                    if ("LENGTH" in [message] and "SESSIONID" in [message] and "ENTRYID" in [message] and "STATEMENT" in [message] and "USERID" in [message] and "USERHOST" in [message] and "ACTION" in [message]
                    and "RETURNCODE" in [message] and "OBJ$CREATOR" in [message] and "OBJ$NAME" in [message] and "OS$USERID" in [message]){
                        #......................................................................#
                        #Using grok to parse msg_init
                        grok {
                            match => {
                                "msg_init" => "%{DATA:eventType}(\s)?\[%{INT:PID}\]:(\s)?LENGTH(\s)?:(\s)?\"%{DATA:length}\" SESSIONID(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:sessionID}\" ENTRYID(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:entryID}\" STATEMENT(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:statement}\" USERID(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:userID}\" USERHOST(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:userHost}\" ACTION(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:action}\" RETURNCODE(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:returnCode}\" OBJ%{DATA:irrelevant}CREATOR(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:obj_creator}\" OBJ%{DATA:irrelevant}NAME(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:obj_name}\" OS%{DATA:irrelevant}USERID(\s)?:(\s)?\[%{INT:irrelevant}\](\s)?\"%{DATA:OS_userID}\""
                            }
                        }
                    }else{
                        #......................................................................#
                        #Using grok to parse msg_init
                        grok {
                            match => {
                                "msg_init" => "%{WORD:eventType}:?(\s)?(%{DATA:slpID})?(\s)?\[%{INT:PID}\]:?(\s)?%{GREEDYDATA:msg}: %{GREEDYDATA:msg_result}"
                                    
                            }
                        }
                        if (![msg] and [msg_result]){
                            mutate {
                                rename => {
                                    "msg_result" => "[msg]"
                                }
                            }
                        }
                        if ([msg_result] and [msg_result]=~/([Dd]isconnected (by|from))|([Rr]eceived [Dd]isconnect)|([Cc]onnection (is )?(closed|reset))/){
                            mutate {
						        add_field => { "[logx][utm][action]" => "Success" }
					        }
                        }else{
                            if ([msg] and [msg]=~/([Dd]isconnected (by|from))|([Rr]eceived [Dd]isconnect)|([Cc]onnection (is )?(closed|reset))/){
                                mutate {
                                    add_field => { "[logx][utm][action]" => "Success" }
                                }
                            }
                        }
                        if ([msg]){
                            #......................................................................#
                            #If the msg_all field contains "from" and "port"
                            if ("from" in [message]) and ("port" in [message]){
                                #......................................................................#
                                #Using grok to parse msg_all
                                grok {
                                    match => {
                                        "msg" => [
                                            "%{GREEDYDATA:irrelevant} from user %{WORD:src_user} %{GREEDYDATA:src_ip} port %{INT:src_port}",
                                            "%{GREEDYDATA:irrelevant}for %{DATA:username} from %{GREEDYDATA:src_ip} port %{INT:src_port}",
                                            "%{GREEDYDATA:irrelevant} from %{GREEDYDATA:src_ip} port %{INT:src_port}"
                                        ]
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #......................................................................#
            #Adding all fields to json tree structure
            mutate {
                rename => { "message" => "[logx][ibm_aix][message]" }
                rename => { "priority" => "[logx][ibm_aix][priority]" }
                rename => { "hostname" => "[logx][ibm_aix][hostname]" }
                rename => { "commandType" => "[logx][ibm_aix][commandType]" }
                rename => { "username" => "[logx][ibm_aix][username]" }
                rename => { "tty" => "[logx][ibm_aix][tty]" }
                rename => { "pwd" => "[logx][ibm_aix][pwd]" }
                rename => { "user" => "[logx][ibm_aix][user]" }
                rename => { "command" => "[logx][ibm_aix][command]" }
                rename => { "src_user" => "[logx][ibm_aix][src_user]" }
                rename => { "dest_user" => "[logx][ibm_aix][dest_user]" }
                rename => { "command_path" => "[logx][ibm_aix][command_path]" }
                rename => { "msg" => "[logx][ibm_aix][msg]" }
                rename => { "msg_result" => "[logx][ibm_aix][msg_result]" }
                rename => { "eventType" => "[logx][ibm_aix][eventType]" }
                rename => { "PID" => "[logx][ibm_aix][PID]" }
                rename => { "length" => "[logx][ibm_aix][length]" }
                rename => { "sessionID" => "[logx][ibm_aix][sessionID]" }
                rename => { "entryID" => "[logx][ibm_aix][entryID]" }
                rename => { "statement" => "[logx][ibm_aix][statement]" }
                rename => { "userID" => "[logx][ibm_aix][userID]" }
                rename => { "userHost" => "[logx][ibm_aix][userHost]" }
                rename => { "action" => "[logx][ibm_aix][action]" }
                rename => { "returnCode" => "[logx][ibm_aix][returnCode]" }
                rename => { "obj_creator" => "[logx][ibm_aix][obj_creator]" }
                rename => { "obj_name" => "[logx][ibm_aix][obj_name]" }
                rename => { "OS_userID" => "[logx][ibm_aix][OS_userID]" }
                rename => { "slpID" => "[logx][ibm_aix][slpID]" }
                rename => { "src_ip" => "[logx][ibm_aix][src_ip]" }
                rename => { "src_port" => "[logx][ibm_aix][src_port]" }
            }
            #......................................................................#
            #Finally, remove unnecessary fields
            mutate {
                remove_field => ["@version","timestamp","path","type","syslog_version",
                "not_defined","msg_all","msg_init","irrelevant"]
            }
        } 
    }
}